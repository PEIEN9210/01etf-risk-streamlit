# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y1jRJvzhlUjdd66vnUOBj57YzwXHYc1s
"""

# app.py
# -*- coding: utf-8 -*-

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import altair as alt
# from scipy.stats import spearmanr

# ===============================
# åŸºæœ¬è¨­å®š
# ===============================
st.set_page_config(page_title="å°ç£ ETF å€‹äººåŒ–æ¨è–¦ç³»çµ±", layout="wide")
st.title("ğŸ“Š å°ç£ ETF å€‹äººåŒ– + HotIndex ETF æ¨è–¦ç³»çµ± (åƒ…ä¾›åƒè€ƒï¼Œä¸è² æŠ•è³‡é¢¨éšª:)")

TRADING_DAYS = 252
RISK_FREE_RATE = 0.01  # ç„¡é¢¨éšªåˆ©ç‡

# ===============================
# ETF Universe & å¸‚å ´åŸºæº–
# ===============================
ETF_LIST = {
    "0050.TW": "è‚¡ç¥¨å‹",
    "006208.TW": "è‚¡ç¥¨å‹",
    "00692.TW": "è‚¡ç¥¨å‹",
    "00757.TW": "è‚¡ç¥¨å‹",
    "0056.TW": "é«˜è‚¡æ¯å‹",
    "00878.TW": "é«˜è‚¡æ¯å‹",
    "00919.TW": "é«˜è‚¡æ¯å‹",
}
MARKET_BENCHMARK = "0050.TW"

# ===============================
# Sidebarï¼šä½¿ç”¨è€…è¨­å®š
# ===============================
st.sidebar.header("ğŸ‘¤ æŠ•è³‡äººé¢¨éšªè¨­å®š")
age = st.sidebar.slider("å¹´é½¡", 20, 80, 35)
horizon = st.sidebar.slider("æŠ•è³‡å¹´é™ï¼ˆå¹´ï¼‰", 1, 30, 10)
loss_tol = st.sidebar.slider("å¯æ¥å—æœ€å¤§æå¤± (%)", 0, 50, 20)
reaction = st.sidebar.radio("å¸‚å ´ä¸‹è·Œ 20% æ™‚", ["è³£å‡º", "è§€æœ›", "åŠ ç¢¼"])

theta = ((80-age)/60 + horizon/30 + loss_tol/50 + {"è³£å‡º":0,"è§€æœ›":0.5,"åŠ ç¢¼":1}[reaction])/4
theta = np.clip(theta,0,1)
st.sidebar.metric("Î¸ï¼ˆé¢¨éšªåå¥½æŒ‡æ•¸ï¼‰", round(theta,2))

# HotIndex vs å€‹äººåŒ–åˆ†æ•¸æ¬Šé‡
st.sidebar.header("âš–ï¸ ç¶œåˆåˆ†æ•¸æ¬Šé‡")
ALPHA = st.sidebar.slider("HotIndex æ¬Šé‡ï¼ˆå€‹äººåŒ–åˆ†æ•¸æ¬Šé‡ = 1 - HotIndex æ¬Šé‡ï¼‰",
                          0.0,1.0,0.5,step=0.05)
st.sidebar.write(f"HotIndex æ¬Šé‡: {ALPHA:.2f} | å€‹äººåŒ–åˆ†æ•¸æ¬Šé‡: {1-ALPHA:.2f}")

# Top N é¡¯ç¤º
st.sidebar.header("ğŸ“ˆ Top N ETF é¡¯ç¤º")
TOP_N = st.sidebar.slider("Top N ETF", 1, len(ETF_LIST), 5)

# Î¸ é¡¯ç¤ºé¸æ“‡ï¼ˆæ”¯æ´ Ranking Robustness å±•ç¤ºï¼‰
theta_display = st.sidebar.select_slider("é¸æ“‡ Î¸ é¡¯ç¤º Top-N",
                                         options=[0.0,0.25,0.5,0.75,1.0],
                                         value=0.5)

# æ˜¯å¦é¡¯ç¤ºå…¨éƒ¨ Î¸ å°æ¯”
show_all_theta = st.sidebar.checkbox("é¡¯ç¤ºå…¨éƒ¨ Î¸ å°æ¯” Top-N åœ–è¡¨", value=False)

# ===============================
# æŠ“å–åƒ¹æ ¼è³‡æ–™ï¼ˆå«æ¯æ—¥è‡ªå‹•åˆ·æ–°ï¼‰
# ===============================
@st.cache_data(ttl=86400)
def fetch_price_data(code, period="1y"):
    df = yf.Ticker(code).history(period=period)
    if df.empty or len(df)<50:
        return None
    return df

# ===============================
# æŒ‡æ¨™è¨ˆç®—
# ===============================
def calc_metrics(df, market_df):
    r = df["Close"].pct_change().dropna()
    mr = market_df["Close"].pct_change().dropna()
    idx = r.index.intersection(mr.index)
    r, mr = r.loc[idx], mr.loc[idx]
    ann_ret = r.mean() * TRADING_DAYS
    ann_vol = r.std() * np.sqrt(TRADING_DAYS)
    sharpe = (ann_ret - RISK_FREE_RATE)/ann_vol if ann_vol>0 else 0
    beta = np.cov(r,mr)[0,1]/np.var(mr)
    return ann_ret*100, ann_vol*100, sharpe, beta

def compute_hot_index(df, window=20):
    volume_ma = df["Volume"].rolling(window).mean().iloc[-1]
    returns = df["Close"].pct_change()
    volatility = returns.rolling(window).std().iloc[-1]
    flow_proxy = (df["Close"]*df["Volume"]).rolling(window).mean().iloc[-1]
    return {"volume_score":volume_ma, "volatility":volatility, "flow_proxy":flow_proxy}

def robust_zscore(series):
    med = np.median(series)
    mad = np.median(np.abs(series - med))
    if mad==0: return pd.Series(0,index=series.index)
    return (series - med)/mad

# ===============================
# å€‹äººåŒ–åˆ†æ•¸ componentï¼ˆÎ¸ é©…å‹•ï¼‰
# ===============================
def compute_personalized_score(ann_ret, ann_vol, sharpe, beta, theta):
    expected_return = 5 + theta*20
    acceptable_vol = 10 + theta*25
    ideal_beta = 0.7 + theta*0.8

    sharpe_fit = min(sharpe/3,1)
    return_fit = np.clip(1 - abs(ann_ret-expected_return)/expected_return,0,1)
    vol_fit = np.clip(1 - ann_vol/acceptable_vol,0,1)
    beta_fit = np.clip(1 - abs(beta-ideal_beta)/ideal_beta,0,1)

    personal_score = np.mean([sharpe_fit, return_fit, vol_fit, beta_fit])

    components = {
        "personal_score": personal_score,
        "sharpe_fit": sharpe_fit,
        "return_fit": return_fit,
        "vol_fit": vol_fit,
        "beta_fit": beta_fit
    }
    return components

# ===============================
# final_score è¨ˆç®—
# ===============================
def compute_final_score(hot_index, personal_score, ALPHA=0.5):
    return ALPHA*hot_index + (1-ALPHA)*personal_score

# ===============================
# å¸‚å ´è³‡æ–™ & theta_rankings
# ===============================
market_df = fetch_price_data(MARKET_BENCHMARK)
theta_rankings = {}

for t in [0.0,0.25,0.5,0.75,1.0]:
    rows = []
    for etf, etf_type in ETF_LIST.items():
        df = fetch_price_data(etf)
        if df is None or market_df is None:
            continue
        ann_ret, ann_vol, sharpe, beta = calc_metrics(df, market_df)
        comp = compute_personalized_score(ann_ret, ann_vol, sharpe, beta, t)
        hot_metrics = compute_hot_index(df)
        hot_index_val = hot_metrics["volume_score"] + hot_metrics["flow_proxy"] - hot_metrics["volatility"]
        final_score = compute_final_score(hot_index_val, comp["personal_score"], ALPHA=ALPHA)

        row = {
            "ETF":etf,
            "é¡å‹":etf_type,
            "Î¸":t,
            "final_score":final_score,
            "hot_index":hot_index_val,
            **comp
        }
        rows.append(row)
    df_theta = pd.DataFrame(rows).sort_values("final_score",ascending=False)
    theta_rankings[t] = df_theta

# ===============================
# UI / Top-N dataframe æ ¹æ“š Sidebar Î¸
# ===============================
df_ui = theta_rankings[theta_display].head(TOP_N)
st.subheader(f"ğŸ¯ Top {TOP_N} ETF æ’åºï¼ˆÎ¸={theta_display}, final_scoreï¼‰")
st.dataframe(df_ui[[
    "ETF","é¡å‹","final_score","personal_score",
    "sharpe_fit","return_fit","vol_fit","beta_fit","hot_index"
]], use_container_width=True)

# ===============================
# é›·é”åœ–ï¼ˆå–®ä¸€ Î¸ï¼‰
# ===============================
st.subheader(f"ğŸ“¡ Top {TOP_N} ETF é›·é”åœ–ï¼ˆé©é…åº¦ Î¸={theta_display}ï¼‰")
metrics = ["sharpe_fit","return_fit","vol_fit","beta_fit"]
radar = df_ui.melt(id_vars="ETF",value_vars=metrics,var_name="æŒ‡æ¨™",value_name="å€¼")
radar["order"] = radar["æŒ‡æ¨™"].map({m:i for i,m in enumerate(metrics)})
radar["è§’åº¦"] = radar["order"]*2*np.pi/len(metrics)
radar["x"] = radar["å€¼"]*np.cos(radar["è§’åº¦"])
radar["y"] = radar["å€¼"]*np.sin(radar["è§’åº¦"])
radar_closed = pd.concat([radar, radar.groupby("ETF").apply(lambda d:d.iloc[[0]]).reset_index(drop=True)],ignore_index=True)

area = alt.Chart(radar_closed).mark_area(opacity=0.3).encode(
    x=alt.X("x:Q",axis=None),
    y=alt.Y("y:Q",axis=None),
    color="ETF:N",
    detail="ETF:N",
    order="order:Q",
    tooltip=["ETF","æŒ‡æ¨™","å€¼"]
)
line = alt.Chart(radar_closed).mark_line().encode(
    x="x:Q",
    y="y:Q",
    color="ETF:N",
    detail="ETF:N",
    order="order:Q"
)
labels = pd.DataFrame({
    "æŒ‡æ¨™":metrics,
    "x":[1.2*np.cos(i*2*np.pi/len(metrics)) for i in range(len(metrics))],
    "y":[1.2*np.sin(i*2*np.pi/len(metrics)) for i in range(len(metrics))]
})
text = alt.Chart(labels).mark_text(fontSize=12).encode(x="x:Q",y="y:Q",text="æŒ‡æ¨™:N")
st.altair_chart(area+line+text,use_container_width=True)

# ===============================
# æ°£æ³¡åœ–ï¼ˆå–®ä¸€ Î¸ï¼‰
# ===============================
st.subheader(f"ğŸ«§ Top {TOP_N} ETF æ°£æ³¡åœ–ï¼ˆSharpe Ã— å€‹äººåŒ–åˆ†æ•¸ Ã— Beta Î¸={theta_display}ï¼‰")
bubble = alt.Chart(df_ui).mark_circle(opacity=0.7,stroke="black",strokeWidth=0.5).encode(
    x=alt.X("sharpe_fit:Q", title="Sharpe Ratio", scale=alt.Scale(zero=False)),
    y=alt.Y("personal_score:Q", title="å€‹äººåŒ–åˆ†æ•¸", scale=alt.Scale(zero=True)),
    size=alt.Size("beta_fit:Q", title="Beta", scale=alt.Scale(range=[100,1600])),
    color=alt.Color("é¡å‹:N", title="ETF é¡å‹"),
    tooltip=["ETF","sharpe_fit","return_fit","vol_fit","beta_fit","personal_score","hot_index","final_score"]
)
st.altair_chart(bubble,use_container_width=True)

# ===============================
# å…¨éƒ¨ Î¸ å°æ¯” Top-N
# ===============================
if show_all_theta:
    st.subheader(f"ğŸ“Š å…¨éƒ¨ Î¸ å°æ¯” Top-{TOP_N}")
    all_rows = []
    for t in [0.0,0.25,0.5,0.75,1.0]:
        df_t = theta_rankings[t].head(TOP_N).copy()
        df_t["Î¸"] = t
        all_rows.append(df_t)
    df_all_theta = pd.concat(all_rows,ignore_index=True)

    # é›·é”åœ–å°æ¯”
    radar_all = df_all_theta.melt(id_vars=["ETF","Î¸"],value_vars=metrics,var_name="æŒ‡æ¨™",value_name="å€¼")
    radar_all["order"] = radar_all["æŒ‡æ¨™"].map({m:i for i,m in enumerate(metrics)})
    radar_all["è§’åº¦"] = radar_all["order"]*2*np.pi/len(metrics)
    radar_all["x"] = radar_all["å€¼"]*np.cos(radar_all["è§’åº¦"])
    radar_all["y"] = radar_all["å€¼"]*np.sin(radar_all["è§’åº¦"])
    radar_all_closed = pd.concat([radar_all, radar_all.groupby(["ETF","Î¸"]).apply(lambda d:d.iloc[[0]]).reset_index(drop=True)],ignore_index=True)

    area_all = alt.Chart(radar_all_closed).mark_area(opacity=0.2).encode(
        x="x:Q",
        y="y:Q",
        color="ETF:N",
        detail="ETF:N",
        tooltip=["ETF","Î¸","æŒ‡æ¨™","å€¼"]
    )
    line_all = alt.Chart(radar_all_closed).mark_line().encode(
        x="x:Q",
        y="y:Q",
        color="ETF:N",
        detail="ETF:N",
        tooltip=["ETF","Î¸","æŒ‡æ¨™","å€¼"]
    )
    st.altair_chart(area_all+line_all,use_container_width=True)

    # æ°£æ³¡åœ–å°æ¯”
    st.subheader(f"ğŸ«§ å…¨éƒ¨ Î¸ æ°£æ³¡åœ–ï¼ˆSharpe Ã— å€‹äººåŒ–åˆ†æ•¸ Ã— Betaï¼‰")
    bubble_all = alt.Chart(df_all_theta).mark_circle(opacity=0.6,stroke="black",strokeWidth=0.5).encode(
        x=alt.X("sharpe_fit:Q", title="Sharpe Ratio"),
        y=alt.Y("personal_score:Q", title="å€‹äººåŒ–åˆ†æ•¸"),
        size=alt.Size("beta_fit:Q", title="Beta", scale=alt.Scale(range=[100,1600])),
        color=alt.Color("Î¸:O", title="Î¸ å€¼"),
        tooltip=["ETF","Î¸","sharpe_fit","return_fit","vol_fit","beta_fit","personal_score","hot_index","final_score"]
    )
    st.altair_chart(bubble_all,use_container_width=True)

    # Spearman correlation / Top-N overlap å¯ä»¥åœ¨é€™è£¡é¡å¤–è¨ˆç®—ä¸¦é¡¯ç¤º
    # st.subheader("ğŸ”— Top-N Spearman ç›¸é—œæ€§è¡¨")
    # spearman_matrix = pd.DataFrame(index=[0.0,0.25,0.5,0.75,1.0], columns=[0.0,0.25,0.5,0.75,1.0])
    # for t1 in [0.0,0.25,0.5,0.75,1.0]:
    #     for t2 in [0.0,0.25,0.5,0.75,1.0]:
    #         df1 = theta_rankings[t1].head(TOP_N)
    #         df2 = theta_rankings[t2].head(TOP_N)
    #         merged = pd.merge(df1[["ETF","final_score"]], df2[["ETF","final_score"]], on="ETF", how="outer", suffixes=("_1","_2")).fillna(0)
    #         spearman_matrix.loc[t1,t2] = round(spearmanr(merged["final_score_1"], merged["final_score_2"]).correlation,2)
    # st.dataframe(spearman_matrix)
