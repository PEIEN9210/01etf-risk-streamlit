# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y1jRJvzhlUjdd66vnUOBj57YzwXHYc1s
"""

# app.py
# -*- coding: utf-8 -*-

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
from datetime import datetime, timedelta
from scipy.stats import spearmanr
import plotly.graph_objects as go
import altair as alt

import streamlit as st

# åˆå§‹åŒ–é é¢ç‹€æ…‹
if "page" not in st.session_state:
    st.session_state.page = "main"
st.sidebar.title("ETF åˆ†æå·¥å…·")

if st.sidebar.button("ğŸ“Š åŸºæœ¬ ETF åˆ†æ"):
    st.session_state.page = "main"

if st.sidebar.button("ğŸ§  ETF é¢¨éšªå› å­åˆ†æ"):
    st.session_state.page = "factor"


# ===============================
# åŸºæœ¬è¨­å®š
# ===============================
st.set_page_config(page_title="å°ç£ ETF å€‹äººåŒ–æ¨è–¦ç³»çµ±", layout="wide")
st.title("ğŸ“Š å°ç£ ETF å€‹äººåŒ– + ç†±é–€ ETF å¤šæº–å‰‡è³‡ç”¢æ’åºæ¡†æ¶ (åƒ…ä¾›åƒè€ƒï¼Œä¸è² æŠ•è³‡é¢¨éšª:)")

TRADING_DAYS = 252
RISK_FREE_RATE = 0.01  # ç„¡é¢¨éšªåˆ©ç‡

# ===============================
# ETF Universe & å¸‚å ´åŸºæº–
# ===============================
ETF_LIST = {
    "0050.TW": "è‚¡ç¥¨å‹",
    "006208.TW": "è‚¡ç¥¨å‹",
    "00692.TW": "è‚¡ç¥¨å‹",
    "00757.TW": "è‚¡ç¥¨å‹",
    "0056.TW": "é«˜è‚¡æ¯å‹",
    "00878.TW": "é«˜è‚¡æ¯å‹",
    "00919.TW": "é«˜è‚¡æ¯å‹",
}
MARKET_BENCHMARK = "0050.TW"

# ===============================
# Sidebarï¼šä½¿ç”¨è€…è¨­å®š
# ===============================
st.sidebar.header("ğŸ‘¤ æŠ•è³‡äººé¢¨éšªè¨­å®š")
age = st.sidebar.slider("å¹´é½¡", 20, 80, 35)
horizon = st.sidebar.slider("æŠ•è³‡å¹´é™ï¼ˆå¹´ï¼‰", 1, 30, 10)
loss_tol = st.sidebar.slider("å¯æ¥å—æœ€å¤§æå¤± (%)", 0, 50, 20)
reaction = st.sidebar.radio("å¸‚å ´ä¸‹è·Œ 20% æ™‚", ["è³£å‡º", "è§€æœ›", "åŠ ç¢¼"])

theta = ((80 - age)/60 + horizon/30 + loss_tol/50 + {"è³£å‡º":0,"è§€æœ›":0.5,"åŠ ç¢¼":1}[reaction])/4
theta = np.clip(theta, 0, 1)
st.sidebar.metric("Î¸ï¼ˆé¢¨éšªåå¥½æŒ‡æ•¸ï¼‰", round(theta, 2))

def alpha_from_theta(theta, alpha_min=0.1, alpha_max=0.7):
    return alpha_min + (alpha_max - alpha_min) * theta

ALPHA_MODEL = alpha_from_theta(theta)

st.sidebar.header("âš–ï¸ ç¶œåˆåˆ†æ•¸æ¬Šé‡")
st.sidebar.write(
    f"ğŸ“Œ HotIndex æ¬Šé‡ (å…§ç”Ÿ Î±ï¼Œä¾ Î¸ è¨ˆç®—): {ALPHA_MODEL:.2f}\n"
    f"ğŸ“Œ å€‹äººåŒ–åˆ†æ•¸æ¬Šé‡: {1-ALPHA_MODEL:.2f}\n"
    "(æ‰‹å‹• slider Î± åƒ…ä¾›åƒè€ƒï¼Œä¸å½±éŸ¿æ’åº)"
)
st.sidebar.slider("HotIndex æ¬Šé‡ï¼ˆåƒ…ä¾›åƒè€ƒï¼‰", 0.0, 1.0, 0.5, step=0.05)

st.sidebar.header("ğŸ“Š æ’åºé¸æ“‡")
sort_option = st.sidebar.selectbox("é¸æ“‡æ’åºä¾æ“š", ["Final Score (HotIndex + å€‹äººåŒ–)", "é¢¨éšªé©é…åˆ†æ•¸ï¼ˆä¾ Î¸ï¼‰"])

st.sidebar.header("ğŸ“ˆ Top N ETF é¡¯ç¤º")
TOP_N = st.sidebar.slider("Top N ETF", 1, len(ETF_LIST), 5)

# ===============================
# æŠ“å–åƒ¹æ ¼è³‡æ–™
# ===============================
@st.cache_data(ttl=86400)
def fetch_all_price_data(etf_list, benchmark, period="1y"):
    data = {}
    tickers = list(etf_list.keys()) + [benchmark]
    for code in set(tickers):
        try:
            df = yf.Ticker(code).history(period=period)
            if not df.empty and len(df) >= 50:
                data[code] = df
        except Exception:
            data[code] = None
    return data

@st.cache_data(ttl=86400)
def fetch_dividend_info(code):
    try:
        ticker = yf.Ticker(code)
        dividends = ticker.dividends
        if dividends is None or dividends.empty:
            return {"æœ€æ–°é…æ¯æ—¥": None, "æœ€è¿‘ä¸€æ¬¡é…æ¯": 0.0, "TTMé…æ¯": 0.0, "TTMæ®–åˆ©ç‡%": 0.0}
        one_year_ago = pd.Timestamp.today() - pd.DateOffset(years=1)
        ttm_dividends = dividends[dividends.index >= one_year_ago]
        latest_date = dividends.index[-1]
        latest_div = float(dividends.iloc[-1])
        ttm_sum = float(ttm_dividends.sum())
        price = ticker.history(period="5d")["Close"].iloc[-1]
        yield_ttm = (ttm_sum / price) * 100 if price > 0 else 0
        return {"æœ€æ–°é…æ¯æ—¥": latest_date.date(), "æœ€è¿‘ä¸€æ¬¡é…æ¯": round(latest_div,3),
                "TTMé…æ¯": round(ttm_sum,3), "TTMæ®–åˆ©ç‡%": round(yield_ttm,2)}
    except Exception:
        return {"æœ€æ–°é…æ¯æ—¥": None, "æœ€è¿‘ä¸€æ¬¡é…æ¯": 0.0, "TTMé…æ¯": 0.0, "TTMæ®–åˆ©ç‡%": 0.0}

# ===============================
# æŒ‡æ¨™è¨ˆç®—
# ===============================
def calc_metrics(df, market_df):
    r = df["Close"].pct_change().dropna()
    mr = market_df["Close"].pct_change().dropna()
    idx = r.index.intersection(mr.index)
    r, mr = r.loc[idx], mr.loc[idx]
    ann_ret = r.mean() * TRADING_DAYS
    ann_vol = r.std() * np.sqrt(TRADING_DAYS)
    sharpe = (ann_ret - RISK_FREE_RATE) / ann_vol if ann_vol>0 else 0
    beta = np.cov(r, mr)[0,1] / np.var(mr)
    return ann_ret*100, ann_vol*100, sharpe, beta

def compute_hot_index(df, window=20):
    volume_ma = df["Volume"].rolling(window).mean().iloc[-1]
    returns = df["Close"].pct_change()
    volatility = returns.rolling(window).std().iloc[-1]
    flow_proxy = (df["Close"]*df["Volume"]).rolling(window).mean().iloc[-1]
    return {"volume_score": volume_ma, "volatility": volatility, "flow_proxy": flow_proxy}

def robust_zscore(series):
    med = np.median(series)
    mad = np.median(np.abs(series - med))
    if mad == 0:
        return pd.Series(0, index=series.index)
    return (series - med)/mad

def compute_personalized_score(ann_ret, ann_vol, sharpe, beta, theta):
    expected_return = 5 + theta * 20
    acceptable_vol = 10 + theta * 25
    ideal_beta = 0.7 + theta * 0.8
    sharpe_fit = min(sharpe/3,1)
    return_fit = np.clip(1 - abs(ann_ret - expected_return)/expected_return,0,1)
    vol_fit = np.clip(1 - ann_vol/acceptable_vol,0,1)
    beta_fit = np.clip(1 - abs(beta - ideal_beta)/ideal_beta,0,1)
    personal_score = np.mean([sharpe_fit, return_fit, vol_fit, beta_fit])
    return {"personal_score": personal_score, "sharpe_fit":sharpe_fit, "return_fit":return_fit,
            "vol_fit":vol_fit,"beta_fit":beta_fit}

def compute_final_score(hot_index_norm, personal_score, alpha):
    return alpha*hot_index_norm + (1-alpha)*personal_score

# ===============================
# ä¸»æµç¨‹
# ===============================
def show_main_page():
    price_data = fetch_all_price_data(ETF_LIST, MARKET_BENCHMARK)
    market_df = price_data.get(MARKET_BENCHMARK)

    rows=[]
    for etf, etf_type in ETF_LIST.items():
        df = price_data.get(etf)
        if df is None or market_df is None:
            continue
        ann_ret, ann_vol, sharpe, beta = calc_metrics(df, market_df)
        comp = compute_personalized_score(ann_ret, ann_vol, sharpe, beta, theta)
        risk_score = comp["vol_fit"]*0.4 + comp["beta_fit"]*0.3 + comp["return_fit"]*0.2 + comp["sharpe_fit"]*0.1
        div_info = fetch_dividend_info(etf)
        hot_metrics = compute_hot_index(df)

        row = {
            "ETF":etf, "é¡å‹":etf_type, "æœ€æ–°åƒ¹":round(df["Close"].iloc[-1],2),
            "æœ€æ–°é…æ¯æ—¥": div_info["æœ€æ–°é…æ¯æ—¥"], "æœ€è¿‘ä¸€æ¬¡é…æ¯":div_info["æœ€è¿‘ä¸€æ¬¡é…æ¯"],
            "TTMé…æ¯":div_info["TTMé…æ¯"], "TTMæ®–åˆ©ç‡%":div_info["TTMæ®–åˆ©ç‡%"],
            "Sharpe":round(sharpe,2),"Beta":round(beta,2),
            "å¹´åŒ–å ±é…¬%":round(ann_ret,2),"å¹´åŒ–æ³¢å‹•%":round(ann_vol,2),
            "å€‹äººåŒ–åˆ†æ•¸":round(comp["personal_score"],3),
            "é¢¨éšªé©é…åˆ†æ•¸":round(risk_score,3),
            "volume_score":hot_metrics["volume_score"],
            "volatility":hot_metrics["volatility"],
            "flow_proxy":hot_metrics["flow_proxy"],
            "Sharpeé©é…":round(comp["sharpe_fit"],2),
            "å ±é…¬é©é…":round(comp["return_fit"],2),
            "æ³¢å‹•é©é…":round(comp["vol_fit"],2),
            "Betaé©é…":round(comp["beta_fit"],2)
        }
        rows.append(row)

    df_all = pd.DataFrame(rows)
    df_all["hot_index"] = df_all["volume_score"] + df_all["flow_proxy"] - df_all["volatility"]
    df_all["hot_index_norm"] = robust_zscore(df_all["hot_index"]).fillna(0)
import statsmodels.api as sm

@st.cache_data(ttl=86400)
def load_factor_data(freq="M"):
    """
    ç°¡åŒ–ç‰ˆï¼šç”¨å°è‚¡å¤§ç›¤ proxy ç•¶å¸‚å ´å› å­
    SMB / HML ç¤ºæ„ç”¨ï¼ˆç ”ç©¶æ™‚ä½ å¯æ›æˆçœŸæ­£å°è‚¡å› å­ï¼‰
    """
    mkt = yf.Ticker("^TWII").history(period="10y")
    mkt["MKT"] = mkt["Close"].pct_change()

    factors = mkt[["MKT"]].dropna()
    factors["SMB"] = 0.0   # placeholder
    factors["HML"] = 0.0   # placeholder
    factors["RF"] = RISK_FREE_RATE / TRADING_DAYS
    return factors.resample(freq).last()


def run_factor_regression(etf_code, freq):
    etf_df = yf.Ticker(etf_code).history(period="10y")
    etf_ret = etf_df["Close"].pct_change().dropna().to_frame("ETF")

    if freq == "M":
        etf_ret = etf_ret.resample("M").last()

    factors = load_factor_data(freq)
    data = etf_ret.join(factors, how="inner")

    Y = data["ETF"] - data["RF"]
    X = data[["MKT", "SMB", "HML"]]
    X = sm.add_constant(X)

    model = sm.OLS(Y, X).fit()
    return model


def show_factor_page():
    st.title("ğŸ§  ETF é¢¨éšªå› å­åˆ†æï¼ˆFactor Regressionï¼‰")

    st.markdown("""
    æœ¬é ä½¿ç”¨ **Fama-French é¡å‹å› å­å›æ­¸æ¨¡å‹**ï¼Œ
    åˆ†æ ETF å ±é…¬çš„ **ç³»çµ±æ€§é¢¨éšªä¾†æº**ï¼Œè€Œéå–®ç´”ç¸¾æ•ˆæ¯”è¼ƒã€‚
    """)

    etf = st.selectbox("é¸æ“‡ ETF", list(ETF_LIST.keys()))
    freq = st.radio("è³‡æ–™é »ç‡", ["æ—¥è³‡æ–™", "æœˆè³‡æ–™"])

    if st.button("é–‹å§‹å› å­å›æ­¸åˆ†æ"):
        model = run_factor_regression(etf, "D" if freq=="æ—¥è³‡æ–™" else "M")

        st.subheader("ğŸ“ å›æ­¸çµæœï¼ˆOLSï¼‰")
        st.text(model.summary())

        st.subheader("ğŸ“Š å› å­æ›éšªè§£è®€")
        st.write({
            "Alphaï¼ˆæˆªè·ï¼‰": round(model.params["const"],6),
            "å¸‚å ´å› å­ Î²": round(model.params["MKT"],3),
            "SMB Î²": round(model.params["SMB"],3),
            "HML Î²": round(model.params["HML"],3),
            "RÂ²": round(model.rsquared,3)
        })
    # === ä½ åŸæœ¬çš„ Î¸ rankingã€Top-Nã€é›·é”åœ–ã€æ°£æ³¡åœ– ===
    # â›” å®Œå…¨ç…§ä½ åŸæœ¬çš„ç¨‹å¼ç¢¼è²¼é€²ä¾†å³å¯ï¼ˆæˆ‘é€™è£¡ä¸å†é‡è¤‡ï¼‰

df_all = pd.DataFrame(rows)
df_all["hot_index"] = df_all["volume_score"] + df_all["flow_proxy"] - df_all["volatility"]
df_all["hot_index_norm"] = robust_zscore(df_all["hot_index"]).fillna(0)

# ===============================
# Ranking by Î¸
# ===============================
THETA_LIST = [0.0,0.25,0.5,0.75,1.0]
theta_rankings = {}

for t in THETA_LIST:
    rows_theta=[]
    for etf, etf_type in ETF_LIST.items():
        df = price_data.get(etf)
        if df is None or market_df is None:
            continue
        ann_ret, ann_vol, sharpe, beta = calc_metrics(df, market_df)
        comp = compute_personalized_score(ann_ret, ann_vol, sharpe, beta, t)
        final_score = compute_final_score(df_all.loc[df_all["ETF"]==etf,"hot_index_norm"].values[0],
                                          comp["personal_score"], ALPHA_MODEL)
        base_row = df_all[df_all["ETF"]==etf].iloc[0]
        row = {"ETF":etf,"é¡å‹":etf_type,"Î¸":t,"æœ€æ–°åƒ¹":base_row["æœ€æ–°åƒ¹"],
               "æœ€æ–°é…æ¯æ—¥":base_row["æœ€æ–°é…æ¯æ—¥"],"æœ€è¿‘ä¸€æ¬¡é…æ¯":base_row["æœ€è¿‘ä¸€æ¬¡é…æ¯"],
               "TTMé…æ¯":base_row["TTMé…æ¯"],"TTMæ®–åˆ©ç‡%":base_row["TTMæ®–åˆ©ç‡%"],
               "final_score":final_score,**comp,"hot_index":base_row["hot_index"]}
        rows_theta.append(row)
    df_theta = pd.DataFrame(rows_theta).sort_values("final_score",ascending=False)
    theta_rankings[t] = df_theta

theta_display_closest = min(THETA_LIST,key=lambda x: abs(x-theta))
df_ui = theta_rankings[theta_display_closest].head(TOP_N)
# ===============================
# é›·é”åœ–å°ˆç”¨è³‡æ–™ï¼ˆTop-N å…§ 0~1 è¦–è¦ºæ­£è¦åŒ–ï¼‰
# ä¸å½±éŸ¿ä»»ä½•åŸæœ¬è¨ˆç®—ã€æ’åºã€è¡¨æ ¼ã€æ°£æ³¡åœ–
# ===============================
radar_metrics = ["sharpe_fit", "return_fit", "vol_fit", "beta_fit"]

df_radar = df_ui.copy()

for col in radar_metrics:
    min_v = df_radar[col].min()
    max_v = df_radar[col].max()
    if max_v > min_v:
        df_radar[col] = (df_radar[col] - min_v) / (max_v - min_v)
    else:
        df_radar[col] = 0.5  # é¿å… Top-N å…¨ç›¸ç­‰æ™‚é™¤ä»¥ 0


# ===============================
# Top-N è¡¨æ ¼
# ===============================
st.subheader(f"ğŸ¯ Top {TOP_N} ETF æ’åºï¼ˆÎ¸={round(theta,2)}, final_scoreï¼‰")
st.dataframe(df_ui[["ETF","é¡å‹","æœ€æ–°åƒ¹","æœ€æ–°é…æ¯æ—¥","æœ€è¿‘ä¸€æ¬¡é…æ¯",
                    "TTMé…æ¯","TTMæ®–åˆ©ç‡%","final_score","personal_score",
                    "sharpe_fit","return_fit","vol_fit","beta_fit","hot_index"]],
             use_container_width=True)

# ===============================
# Top-N é›·é”åœ– (Plotlyï¼ŒTop-N å…§ 0~1 æ”¾å¤§é¡¯ç¤º)
# ===============================
st.subheader(f"ğŸ•¸ï¸ Top {TOP_N} ETF å¤šæŒ‡æ¨™é›·é”åœ–")

radar_labels = ["Sharpe", "Return", "Volatility", "Beta"]

fig = go.Figure()

for _, row in df_radar.iterrows():
    values = [row[m] for m in radar_metrics]
    values.append(values[0])  # é–‰åˆ

    fig.add_trace(go.Scatterpolar(
        r=values,
        theta=radar_labels + [radar_labels[0]],
        fill="toself",
        name=row["ETF"],
        opacity=0.6
    ))

fig.update_layout(
    polar=dict(
        radialaxis=dict(
            visible=True,
            range=[0, 1]
        )
    ),
    showlegend=True,
    margin=dict(l=40, r=40, t=40, b=60)
)

st.plotly_chart(fig, use_container_width=True)
# ===============================
# Top-N æ°£æ³¡åœ–
# ===============================
st.subheader(f"ğŸ’­ Top {TOP_N} ETF æ°£æ³¡åœ–ï¼ˆÎ¸={round(theta,2)}ï¼‰")
bubble = alt.Chart(df_ui).mark_circle(opacity=0.7, stroke="black", strokeWidth=0.5).encode(
    x=alt.X("sharpe_fit:Q", title="Sharpe é©é…"),
    y=alt.Y("personal_score:Q", title="å€‹äººåŒ–åˆ†æ•¸"),
    size=alt.Size("beta_fit:Q", title="Beta é©é…", scale=alt.Scale(range=[100,1600])),
    color=alt.Color("é¡å‹:N", title="ETF é¡å‹"),
    tooltip=["ETF","sharpe_fit","return_fit","vol_fit","beta_fit",
             "personal_score","hot_index","final_score"]
)
st.altair_chart(bubble, use_container_width=True)
