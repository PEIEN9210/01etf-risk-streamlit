# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y1jRJvzhlUjdd66vnUOBj57YzwXHYc1s
"""

# app.py
# -*- coding: utf-8 -*-
import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import altair as alt
from datetime import datetime, timedelta
from scipy.stats import spearmanr

# ===============================
# åŸºæœ¬è¨­å®š
# ===============================
st.set_page_config(page_title="å°ç£ ETF å€‹äººåŒ–æ¨è–¦ç³»çµ±", layout="wide")
st.title("ğŸ“Š å°ç£ ETF å€‹äººåŒ– + HotIndex ETF æ¨è–¦ç³»çµ± (åƒ…ä¾›åƒè€ƒï¼Œä¸è² æŠ•è³‡é¢¨éšª)")

TRADING_DAYS = 252
RISK_FREE_RATE = 0.01

# ===============================
# ETF Universe & å¸‚å ´åŸºæº–
# ===============================
ETF_LIST = {
    "0050.TW": "è‚¡ç¥¨å‹",
    "006208.TW": "è‚¡ç¥¨å‹",
    "00692.TW": "è‚¡ç¥¨å‹",
    "00757.TW": "è‚¡ç¥¨å‹",
    "0056.TW": "é«˜è‚¡æ¯å‹",
    "00878.TW": "é«˜è‚¡æ¯å‹",
    "00919.TW": "é«˜è‚¡æ¯å‹",
}
MARKET_BENCHMARK = "0050.TW"

# ===============================
# Sidebarï¼šä½¿ç”¨è€…è¨­å®š
# ===============================
st.sidebar.header("ğŸ‘¤ æŠ•è³‡äººé¢¨éšªè¨­å®š")
age = st.sidebar.slider("å¹´é½¡", 20, 80, 35)
horizon = st.sidebar.slider("æŠ•è³‡å¹´é™ï¼ˆå¹´ï¼‰", 1, 30, 10)
loss_tol = st.sidebar.slider("å¯æ¥å—æœ€å¤§æå¤± (%)", 0, 50, 20)
reaction = st.sidebar.radio("å¸‚å ´ä¸‹è·Œ 20% æ™‚", ["è³£å‡º", "è§€æœ›", "åŠ ç¢¼"])

# theta è¨ˆç®—
theta = ((80-age)/60 + horizon/30 + loss_tol/50 + {"è³£å‡º":0,"è§€æœ›":0.5,"åŠ ç¢¼":1}[reaction])/4
theta = np.clip(theta,0,1)
st.sidebar.metric("Î¸ï¼ˆé¢¨éšªåå¥½æŒ‡æ•¸ï¼‰", round(theta,2))

# HotIndex vs å€‹äººåŒ–åˆ†æ•¸æ¬Šé‡
st.sidebar.header("âš–ï¸ ç¶œåˆåˆ†æ•¸æ¬Šé‡")
ALPHA = st.sidebar.slider("HotIndex æ¬Šé‡ï¼ˆå€‹äººåŒ–åˆ†æ•¸æ¬Šé‡ = 1 - HotIndex æ¬Šé‡ï¼‰", 0.0, 1.0, 0.5, step=0.05)
st.sidebar.write(f"HotIndex æ¬Šé‡: {ALPHA:.2f} | å€‹äººåŒ–åˆ†æ•¸æ¬Šé‡: {1-ALPHA:.2f}")

# æ’åºé¸é …
st.sidebar.header("ğŸ“Š æ’åºé¸é …")
sort_option = st.sidebar.selectbox(
    "é¸æ“‡æ’åºä¾æ“š",
    ["Final Score (HotIndex + å€‹äººåŒ–)","é¢¨éšªé©é…åˆ†æ•¸ï¼ˆä¾ Î¸ï¼‰"]
)

# Top N é¡¯ç¤º
st.sidebar.header("ğŸ“ˆ Top N ETF é¡¯ç¤º")
TOP_N = st.sidebar.slider("Top N ETF", 1, len(ETF_LIST), 5)

# ===============================
# æŠ“å–åƒ¹æ ¼è³‡æ–™
# ===============================
@st.cache_data(ttl=86400)
def fetch_price_data(code, period="1y"):
    df = yf.Ticker(code).history(period=period)
    if df.empty or len(df)<50:
        return None
    return df

# ===============================
# æŒ‡æ¨™è¨ˆç®—
# ===============================
def calc_metrics(df, market_df):
    r = df["Close"].pct_change().dropna()
    mr = market_df["Close"].pct_change().dropna()
    idx = r.index.intersection(mr.index)
    r, mr = r.loc[idx], mr.loc[idx]
    ann_ret = r.mean() * TRADING_DAYS
    ann_vol = r.std() * np.sqrt(TRADING_DAYS)
    sharpe = (ann_ret - RISK_FREE_RATE)/ann_vol if ann_vol>0 else 0
    beta = np.cov(r,mr)[0,1]/np.var(mr)
    return ann_ret*100, ann_vol*100, sharpe, beta

def compute_hot_index(df, window=20):
    volume_ma = df["Volume"].rolling(window).mean().iloc[-1]
    returns = df["Close"].pct_change()
    volatility = returns.rolling(window).std().iloc[-1]
    flow_proxy = (df["Close"]*df["Volume"]).rolling(window).mean().iloc[-1]
    return {"volume_score":volume_ma, "volatility":volatility, "flow_proxy":flow_proxy}

def robust_zscore(series):
    med = np.median(series)
    mad = np.median(np.abs(series - med))
    if mad==0:
        return pd.Series(0,index=series.index)
    return (series - med)/mad

# ===============================
# è¨ˆç®—å€‹äººåŒ–åˆ†æ•¸ componentï¼ˆÎ¸ é©…å‹•ï¼‰
# ===============================
def compute_personalized_score(ann_ret, ann_vol, sharpe, beta, theta):
    expected_return = 5 + theta*20
    acceptable_vol = 10 + theta*25
    ideal_beta = 0.7 + theta*0.8
    sharpe_fit = min(sharpe/3,1)
    return_fit = np.clip(1 - abs(ann_ret-expected_return)/expected_return,0,1)
    vol_fit = np.clip(1 - ann_vol/acceptable_vol,0,1)
    beta_fit = np.clip(1 - abs(beta-ideal_beta)/ideal_beta,0,1)
    personal_score = np.mean([sharpe_fit, return_fit, vol_fit, beta_fit])
    return {
        "personal_score": personal_score,
        "sharpe_fit": sharpe_fit,
        "return_fit": return_fit,
        "vol_fit": vol_fit,
        "beta_fit": beta_fit
    }

def compute_final_score(hot_index, personal_score, ALPHA=0.5):
    return ALPHA*hot_index + (1-ALPHA)*personal_score

# ===============================
# ä¸»æµç¨‹ï¼šè¨ˆç®— ETF åˆ†æ•¸ + æ”¯æ´ä¸åŒ Î¸
# ===============================
market_df = fetch_price_data(MARKET_BENCHMARK)
theta_rankings = {}

THETA_LIST = [0.0, 0.25, 0.5, 0.75, 1.0]

for t in THETA_LIST:
    rows = []
    for etf, etf_type in ETF_LIST.items():
        df = fetch_price_data(etf)
        if df is None or market_df is None:
            continue
        ann_ret, ann_vol, sharpe, beta = calc_metrics(df, market_df)
        comp = compute_personalized_score(ann_ret, ann_vol, sharpe, beta, t)
        hot_metrics = compute_hot_index(df)
        hot_index_val = hot_metrics["volume_score"] + hot_metrics["flow_proxy"] - hot_metrics["volatility"]
        final_score_val = compute_final_score(hot_index_val, comp["personal_score"], ALPHA)
        row = {
            "ETF": etf,
            "é¡å‹": etf_type,
            "Î¸": t,
            "final_score": final_score_val,
            **comp,
            "hot_index": hot_index_val
        }
        rows.append(row)
    df_theta = pd.DataFrame(rows).sort_values("final_score", ascending=False)
    theta_rankings[t] = df_theta

# ===============================
# Top-N & UI ç”¨ df
# ===============================
df_ui = theta_rankings[theta].head(TOP_N)  # æ ¹æ“š Sidebar theta å³æ™‚æ›´æ–°

st.subheader(f"ğŸ¯ Top {TOP_N} ETF æ’åºï¼ˆÎ¸={theta:.2f}, final_scoreï¼‰")
st.dataframe(df_ui[[
    "ETF","é¡å‹","final_score","personal_score",
    "sharpe_fit","return_fit","vol_fit","beta_fit","hot_index"
]], use_container_width=True)

# ===============================
# é›·é”åœ–ï¼ˆTop-Nï¼‰éš¨ Î¸ æ›´æ–°
# ===============================
st.subheader(f"ğŸ“¡ Top {TOP_N} ETF é›·é”åœ–ï¼ˆé©é…åº¦ï¼‰")
metrics = ["sharpe_fit","return_fit","vol_fit","beta_fit"]
radar = df_ui.melt(id_vars="ETF", value_vars=metrics, var_name="æŒ‡æ¨™", value_name="å€¼")
radar["order"] = radar["æŒ‡æ¨™"].map({m:i for i,m in enumerate(metrics)})
radar["è§’åº¦"] = radar["order"]*2*np.pi/len(metrics)
radar["x"] = radar["å€¼"]*np.cos(radar["è§’åº¦"])
radar["y"] = radar["å€¼"]*np.sin(radar["è§’åº¦"])
radar_closed = pd.concat([radar, radar.groupby("ETF").apply(lambda d:d.iloc[[0]]).reset_index(drop=True)], ignore_index=True)

area = alt.Chart(radar_closed).mark_area(opacity=0.3).encode(
    x="x:Q", y="y:Q", color="ETF:N", detail="ETF:N",
    tooltip=["ETF","æŒ‡æ¨™","å€¼"]
)
line = alt.Chart(radar_closed).mark_line().encode(
    x="x:Q", y="y:Q", color="ETF:N", detail="ETF:N"
)
st.altair_chart(area+line, use_container_width=True)

# ===============================
# æ°£æ³¡åœ–ï¼ˆTop-Nï¼‰éš¨ Î¸ æ›´æ–°
# ===============================
st.subheader(f"ğŸ«§ Top {TOP_N} ETF æ°£æ³¡åœ–ï¼ˆSharpe Ã— å€‹äººåŒ–åˆ†æ•¸ Ã— Betaï¼‰")
bubble = alt.Chart(df_ui).mark_circle(opacity=0.7, stroke="black", strokeWidth=0.5).encode(
    x=alt.X("sharpe_fit:Q", title="Sharpe é©é…åº¦"),
    y=alt.Y("personal_score:Q", title="å€‹äººåŒ–åˆ†æ•¸"),
    size=alt.Size("beta_fit:Q", title="Beta é©é…åº¦", scale=alt.Scale(range=[100,1600])),
    color=alt.Color("é¡å‹:N", title="ETF é¡å‹"),
    tooltip=["ETF","sharpe_fit","return_fit","vol_fit","beta_fit","personal_score","hot_index","final_score"]
)
st.altair_chart(bubble,use_container_width=True)
