# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y1jRJvzhlUjdd66vnUOBj57YzwXHYc1s
"""

# app.py
# -*- coding: utf-8 -*-

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import altair as alt
from datetime import datetime, timedelta
from scipy.stats import spearmanr

# ===============================
# åŸºæœ¬è¨­å®š
# ===============================
st.set_page_config(page_title="å°ç£ ETF å€‹äººåŒ–æ¨è–¦ç³»çµ±", layout="wide")
st.title("ğŸ“Š å°ç£ ETF å€‹äººåŒ– + HotIndex ETF æ¨è–¦ç³»çµ± (åƒ…ä¾›åƒè€ƒï¼Œä¸è² æŠ•è³‡é¢¨éšª:)")

TRADING_DAYS = 252
RISK_FREE_RATE = 0.01  # ç„¡é¢¨éšªåˆ©ç‡

# ===============================
# ETF Universe & å¸‚å ´åŸºæº–
# ===============================
ETF_LIST = {
    "0050.TW": "è‚¡ç¥¨å‹",
    "006208.TW": "è‚¡ç¥¨å‹",
    "00692.TW": "è‚¡ç¥¨å‹",
    "00757.TW": "è‚¡ç¥¨å‹",
    "0056.TW": "é«˜è‚¡æ¯å‹",
    "00878.TW": "é«˜è‚¡æ¯å‹",
    "00919.TW": "é«˜è‚¡æ¯å‹",
}
MARKET_BENCHMARK = "0050.TW"

# ===============================
# Sidebarï¼šä½¿ç”¨è€…è¨­å®š
# ===============================
st.sidebar.header("ğŸ‘¤ æŠ•è³‡äººé¢¨éšªè¨­å®š")
age = st.sidebar.slider("å¹´é½¡", 20, 80, 35, key="age_slider")
horizon = st.sidebar.slider("æŠ•è³‡å¹´é™ï¼ˆå¹´ï¼‰", 1, 30, 10, key="horizon_slider")
loss_tol = st.sidebar.slider("å¯æ¥å—æœ€å¤§æå¤± (%)", 0, 50, 20, key="loss_slider")
reaction = st.sidebar.radio("å¸‚å ´ä¸‹è·Œ 20% æ™‚", ["è³£å‡º", "è§€æœ›", "åŠ ç¢¼"], key="reaction_radio")

# è¨ˆç®— Î¸
theta = ((80-age)/60 + horizon/30 + loss_tol/50 + {"è³£å‡º":0,"è§€æœ›":0.5,"åŠ ç¢¼":1}[reaction])/4
theta = np.clip(theta,0,1)
st.sidebar.metric("Î¸ï¼ˆé¢¨éšªåå¥½æŒ‡æ•¸ï¼‰", round(theta,2))

# HotIndex vs å€‹äººåŒ–åˆ†æ•¸æ¬Šé‡
st.sidebar.header("âš–ï¸ ç¶œåˆåˆ†æ•¸æ¬Šé‡")
ALPHA = st.sidebar.slider(
    "HotIndex æ¬Šé‡ï¼ˆå€‹äººåŒ–åˆ†æ•¸æ¬Šé‡ = 1 - HotIndex æ¬Šé‡ï¼‰",
    0.0, 1.0, 0.5, step=0.05, key="alpha_slider"
)
st.sidebar.write(f"HotIndex æ¬Šé‡: {ALPHA:.2f} | å€‹äººåŒ–åˆ†æ•¸æ¬Šé‡: {1-ALPHA:.2f}")

# æ’åºé¸é …
st.sidebar.header("ğŸ“Š æ’åºé¸æ“‡")
sort_option = st.sidebar.selectbox(
    "é¸æ“‡æ’åºä¾æ“š",
    ["Final Score (HotIndex + å€‹äººåŒ–)","é¢¨éšªé©é…åˆ†æ•¸ï¼ˆä¾ Î¸ï¼‰"],
    key="sort_option"
)

# Top N é¡¯ç¤º
st.sidebar.header("ğŸ“ˆ Top N ETF é¡¯ç¤º")
TOP_N = st.sidebar.slider("Top N ETF", 1, len(ETF_LIST), 5, key="topn_slider")

# ===============================
# æŠ“å–åƒ¹æ ¼è³‡æ–™ï¼ˆå«æ¯æ—¥è‡ªå‹•åˆ·æ–°ï¼‰
# ===============================
@st.cache_data(ttl=86400)
def fetch_price_data(code, period="1y"):
    df = yf.Ticker(code).history(period=period)
    if df.empty or len(df) < 50:
        return None
    return df

# ===============================
# æŒ‡æ¨™è¨ˆç®—
# ===============================
def calc_metrics(df, market_df):
    r = df["Close"].pct_change().dropna()
    mr = market_df["Close"].pct_change().dropna()
    idx = r.index.intersection(mr.index)
    r, mr = r.loc[idx], mr.loc[idx]

    ann_ret = r.mean() * TRADING_DAYS
    ann_vol = r.std() * np.sqrt(TRADING_DAYS)
    sharpe = (ann_ret - RISK_FREE_RATE)/ann_vol if ann_vol>0 else 0
    beta = np.cov(r,mr)[0,1]/np.var(mr)
    return ann_ret*100, ann_vol*100, sharpe, beta

def compute_hot_index(df, window=20):
    volume_ma = df["Volume"].rolling(window).mean().iloc[-1]
    returns = df["Close"].pct_change()
    volatility = returns.rolling(window).std().iloc[-1]
    flow_proxy = (df["Close"]*df["Volume"]).rolling(window).mean().iloc[-1]
    return {"volume_score":volume_ma, "volatility":volatility, "flow_proxy":flow_proxy}

def robust_zscore(series):
    med = np.median(series)
    mad = np.median(np.abs(series - med))
    if mad==0:
        return pd.Series(0,index=series.index)
    return (series - med)/mad

# ===============================
# ä¸»æµç¨‹ï¼šè¨ˆç®— ETF åˆ†æ•¸
# ===============================
market_df = fetch_price_data(MARKET_BENCHMARK)
rows = []

for etf, etf_type in ETF_LIST.items():
    df = fetch_price_data(etf)
    if df is None or market_df is None:
        continue

    ann_ret, ann_vol, sharpe, beta = calc_metrics(df, market_df)

    # å€‹äººåŒ–é©é…
    expected_return = 5 + theta*20
    acceptable_vol = 10 + theta*25
    ideal_beta = 0.7 + theta*0.8

    sharpe_fit = min(sharpe/3,1)
    return_fit = np.clip(1 - abs(ann_ret-expected_return)/expected_return,0,1)
    vol_fit = np.clip(1 - ann_vol/acceptable_vol,0,1)
    beta_fit = np.clip(1 - abs(beta-ideal_beta)/ideal_beta,0,1)

    # é¢¨éšªé©é…åˆ†æ•¸ï¼ˆåŠ æ¬Šï¼‰
    risk_score = vol_fit*0.4 + beta_fit*0.3 + return_fit*0.2 + sharpe_fit*0.1

    personal_score = np.mean([sharpe_fit, return_fit, vol_fit, beta_fit])

    # HotIndex
    hot_metrics = compute_hot_index(df)
    row = {
        "ETF":etf,
        "é¡å‹":etf_type,
        "æœ€æ–°åƒ¹":round(df["Close"].iloc[-1],2),
        "Sharpe":round(sharpe,2),
        "Beta":round(beta,2),
        "å¹´åŒ–å ±é…¬%":round(ann_ret,2),
        "å¹´åŒ–æ³¢å‹•%":round(ann_vol,2),
        "å€‹äººåŒ–åˆ†æ•¸":round(personal_score,3),
        "é¢¨éšªé©é…åˆ†æ•¸":round(risk_score,3),
        "volume_score":hot_metrics["volume_score"],
        "volatility":hot_metrics["volatility"],
        "flow_proxy":hot_metrics["flow_proxy"],
        "Sharpeé©é…":round(sharpe_fit,2),
        "å ±é…¬é©é…":round(return_fit,2),
        "æ³¢å‹•é©é…":round(vol_fit,2),
        "Betaé©é…":round(beta_fit,2)
    }
    rows.append(row)

df_all = pd.DataFrame(rows)

# HotIndex z-score
for col in ["volume_score","volatility","flow_proxy"]:
    df_all[col+"_z"] = robust_zscore(df_all[col])
df_all["hot_index"] = df_all[["volume_score_z","volatility_z","flow_proxy_z"]].sum(axis=1)

# ===============================
# è¨ˆç®—å€‹äººåŒ–åˆ†æ•¸ componentï¼ˆÎ¸ é©…å‹•ï¼‰
# ===============================
def compute_personalized_score(ann_ret, ann_vol, sharpe, beta, theta):
    expected_return = 5 + theta*20
    acceptable_vol = 10 + theta*25
    ideal_beta = 0.7 + theta*0.8

    sharpe_fit = min(sharpe/3,1)
    return_fit = np.clip(1 - abs(ann_ret-expected_return)/expected_return,0,1)
    vol_fit = np.clip(1 - ann_vol/acceptable_vol,0,1)
    beta_fit = np.clip(1 - abs(beta-ideal_beta)/ideal_beta,0,1)

    personal_score = np.mean([sharpe_fit, return_fit, vol_fit, beta_fit])

    return {
        "personal_score": personal_score,
        "sharpe_fit": sharpe_fit,
        "return_fit": return_fit,
        "vol_fit": vol_fit,
        "beta_fit": beta_fit
    }

def compute_final_score(hot_index, personal_score, ALPHA=0.5):
    return ALPHA*hot_index + (1-ALPHA)*personal_score

# ===============================
# æ”¯æ´ä¸åŒ Î¸ çš„å€‹äººåŒ–æ’åºï¼ˆæ–¹æ³•ä¸€ Ranking Robustnessï¼‰
# ===============================
THETA_LIST = [0.0, 0.25, 0.5, 0.75, 1.0]
theta_rankings = {}

for t in THETA_LIST:
    rows = []
    for etf, etf_type in ETF_LIST.items():
        df = fetch_price_data(etf)
        if df is None or market_df is None:
            continue
        ann_ret, ann_vol, sharpe, beta = calc_metrics(df, market_df)
        comp = compute_personalized_score(ann_ret, ann_vol, sharpe, beta, t)
        hot_metrics = compute_hot_index(df)
        final_score = compute_final_score(hot_metrics["volume_score"] + hot_metrics["flow_proxy"] - hot_metrics["volatility"],
                                          comp["personal_score"], ALPHA=ALPHA)
        row = {
            "ETF": etf,
            "é¡å‹": etf_type,
            "Î¸": t,
            "final_score": final_score,
            **comp,
            "hot_index": hot_metrics["volume_score"] + hot_metrics["flow_proxy"] - hot_metrics["volatility"]
        }
        rows.append(row)
    df_theta = pd.DataFrame(rows)
    df_theta = df_theta.sort_values("final_score", ascending=False)
    theta_rankings[t] = df_theta

# ===============================
# Sidebar Î¸ å°æ‡‰æœ€è¿‘é„° THETA_LIST
# ===============================
theta_display_closest = min(THETA_LIST, key=lambda x: abs(x - theta))
df_ui = theta_rankings[theta_display_closest].head(TOP_N)

# ===============================
# UI / Top-N å±•ç¤º
# ===============================
st.subheader(f"ğŸ¯ Top {TOP_N} ETF æ’åºï¼ˆÎ¸={round(theta,2)}, final_scoreï¼‰")
st.dataframe(df_ui[[
    "ETF","é¡å‹","final_score","personal_score",
    "sharpe_fit","return_fit","vol_fit","beta_fit","hot_index"
]], use_container_width=True)

# ===============================
# é›·é”åœ–
# ===============================
st.subheader(f"ğŸ“¡ Top {TOP_N} ETF é›·é”åœ–ï¼ˆÎ¸={round(theta,2)}ï¼‰")
metrics = ["sharpe_fit","return_fit","vol_fit","beta_fit"]
radar = df_ui.melt(id_vars="ETF",value_vars=metrics,var_name="æŒ‡æ¨™",value_name="å€¼")
radar["order"] = radar["æŒ‡æ¨™"].map({m:i for i,m in enumerate(metrics)})
radar["è§’åº¦"] = radar["order"]*2*np.pi/len(metrics)
radar["x"] = radar["å€¼"]*np.cos(radar["è§’åº¦"])
radar["y"] = radar["å€¼"]*np.sin(radar["è§’åº¦"])
radar_closed = pd.concat([radar, radar.groupby("ETF").apply(lambda d:d.iloc[[0]]).reset_index(drop=True)],ignore_index=True)

area = alt.Chart(radar_closed).mark_area(opacity=0.3).encode(
    x=alt.X("x:Q",axis=None),
    y=alt.Y("y:Q",axis=None),
    color="ETF:N",
    detail="ETF:N",
    order="order:Q",
    tooltip=["ETF","æŒ‡æ¨™","å€¼"]
)
line = alt.Chart(radar_closed).mark_line().encode(
    x="x:Q",
    y="y:Q",
    color="ETF:N",
    detail="ETF:N",
    order="order:Q"
)
labels = pd.DataFrame({
    "æŒ‡æ¨™":metrics,
    "x":[1.2*np.cos(i*2*np.pi/len(metrics)) for i in range(len(metrics))],
    "y":[1.2*np.sin(i*2*np.pi/len(metrics)) for i in range(len(metrics))]
})
text = alt.Chart(labels).mark_text(fontSize=12).encode(x="x:Q",y="y:Q",text="æŒ‡æ¨™:N")
st.altair_chart(area+line+text,use_container_width=True)

# ===============================
# æ°£æ³¡åœ–
# ===============================
st.subheader(f"ğŸ«§ Top {TOP_N} ETF æ°£æ³¡åœ–ï¼ˆÎ¸={round(theta,2)}ï¼‰")
bubble = alt.Chart(df_ui).mark_circle(opacity=0.7,stroke="black",strokeWidth=0.5).encode(
    x=alt.X("sharpe_fit:Q", title="Sharpe é©é…"),
    y=alt.Y("personal_score:Q", title="å€‹äººåŒ–åˆ†æ•¸"),
    size=alt.Size("beta_fit:Q", title="Beta é©é…", scale=alt.Scale(range=[100,1600])),
    color=alt.Color("é¡å‹:N", title="ETF é¡å‹"),
    tooltip=["ETF","sharpe_fit","return_fit","vol_fit","beta_fit","personal_score","hot_index","final_score"]
)
st.altair_chart(bubble,use_container_width=True)
