# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y1jRJvzhlUjdd66vnUOBj57YzwXHYc1s
"""

# app.py
# -*- coding: utf-8 -*-

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import altair as alt
from scipy.stats import spearmanr

# ===============================
# åŸºæœ¬è¨­å®š
# ===============================
st.set_page_config(page_title="å°ç£ ETF å€‹äººåŒ–æ¨è–¦ç³»çµ±", layout="wide")
st.title("ğŸ“Š å°ç£ ETF å€‹äººåŒ– + ç†±é–€ ETF å¤šæº–å‰‡è³‡ç”¢æ’åºæ¡†æ¶ï¼ˆåƒ…ä¾›å­¸è¡“èˆ‡æ¨¡å‹ç¤ºç¯„ç”¨é€”ï¼‰")

TRADING_DAYS = 252
RISK_FREE_RATE = 0.01

# ===============================
# ETF Universe
# ===============================
ETF_LIST = {
    "0050.TW": "è‚¡ç¥¨å‹",
    "006208.TW": "è‚¡ç¥¨å‹",
    "00692.TW": "è‚¡ç¥¨å‹",
    "00757.TW": "è‚¡ç¥¨å‹",
    "0056.TW": "é«˜è‚¡æ¯å‹",
    "00878.TW": "é«˜è‚¡æ¯å‹",
    "00919.TW": "é«˜è‚¡æ¯å‹",
}
MARKET_BENCHMARK = "0050.TW"

# ===============================
# Sidebarï¼šä½¿ç”¨è€…è¨­å®š
# ===============================
st.sidebar.header("ğŸ‘¤ æŠ•è³‡äººé¢¨éšªè¨­å®š")
age = st.sidebar.slider("å¹´é½¡", 20, 80, 35)
horizon = st.sidebar.slider("æŠ•è³‡å¹´é™ï¼ˆå¹´ï¼‰", 1, 30, 10)
loss_tol = st.sidebar.slider("å¯æ¥å—æœ€å¤§æå¤± (%)", 0, 50, 20)
reaction = st.sidebar.radio("å¸‚å ´ä¸‹è·Œ 20% æ™‚", ["è³£å‡º", "è§€æœ›", "åŠ ç¢¼"])

theta = (
    (80 - age) / 60
    + horizon / 30
    + loss_tol / 50
    + {"è³£å‡º": 0, "è§€æœ›": 0.5, "åŠ ç¢¼": 1}[reaction]
) / 4
theta = np.clip(theta, 0, 1)
st.sidebar.metric("Î¸ï¼ˆé¢¨éšªåå¥½æŒ‡æ•¸ï¼‰", round(theta, 2))

def alpha_from_theta(theta, a_min=0.1, a_max=0.7):
    return a_min + (a_max - a_min) * theta

ALPHA_MODEL = alpha_from_theta(theta)

# ===============================
# è³‡æ–™æŠ“å–ï¼ˆåƒ¹æ ¼ + é…æ¯ï¼‰
# ===============================
@st.cache_data(ttl=86400)
def fetch_price_data(code, period="1y"):
    df = yf.Ticker(code).history(period=period)
    return None if df.empty or len(df) < 50 else df

@st.cache_data(ttl=86400)
def fetch_dividend_info(code):
    try:
        div = yf.Ticker(code).dividends
        if div is None or div.empty:
            return None, 0.0
        return div.index[-1].date(), round(float(div.iloc[-1]), 3)
    except Exception:
        return None, 0.0

@st.cache_data(ttl=86400)
def fetch_all_price_data(etfs, benchmark):
    data = {}
    for code in set(list(etfs.keys()) + [benchmark]):
        try:
            df = yf.Ticker(code).history(period="1y")
            if not df.empty and len(df) >= 50:
                data[code] = df
        except Exception:
            pass
    return data

# ===============================
# æŒ‡æ¨™è¨ˆç®—
# ===============================
def calc_metrics(df, market_df):
    r = df["Close"].pct_change().dropna()
    mr = market_df["Close"].pct_change().dropna()
    idx = r.index.intersection(mr.index)
    r, mr = r.loc[idx], mr.loc[idx]

    ann_ret = r.mean() * TRADING_DAYS
    ann_vol = r.std() * np.sqrt(TRADING_DAYS)
    sharpe = (ann_ret - RISK_FREE_RATE) / ann_vol if ann_vol > 0 else 0
    beta = np.cov(r, mr)[0, 1] / np.var(mr)
    return ann_ret * 100, ann_vol * 100, sharpe, beta

def compute_hot_index(df, window=20):
    vol_ma = df["Volume"].rolling(window).mean().iloc[-1]
    flow = (df["Close"] * df["Volume"]).rolling(window).mean().iloc[-1]
    volat = df["Close"].pct_change().rolling(window).std().iloc[-1]
    return vol_ma, flow, volat

def robust_z(series):
    med = np.median(series)
    mad = np.median(np.abs(series - med))
    return pd.Series(0, index=series.index) if mad == 0 else (series - med) / mad

# ===============================
# ä¸»æµç¨‹
# ===============================
price_data = fetch_all_price_data(ETF_LIST, MARKET_BENCHMARK)
market_df = price_data.get(MARKET_BENCHMARK)

rows = []

for etf, etf_type in ETF_LIST.items():
    df = price_data.get(etf)
    if df is None or market_df is None:
        continue

    ann_ret, ann_vol, sharpe, beta = calc_metrics(df, market_df)
    div_date, div_amt = fetch_dividend_info(etf)

    expected_return = 5 + theta * 20
    acceptable_vol = 10 + theta * 25
    ideal_beta = 0.7 + theta * 0.8

    sharpe_fit = min(sharpe / 3, 1)
    return_fit = np.clip(1 - abs(ann_ret - expected_return) / expected_return, 0, 1)
    vol_fit = np.clip(1 - ann_vol / acceptable_vol, 0, 1)
    beta_fit = np.clip(1 - abs(beta - ideal_beta) / ideal_beta, 0, 1)

    personal_score = np.mean([sharpe_fit, return_fit, vol_fit, beta_fit])

    vol_ma, flow, volat = compute_hot_index(df)

    rows.append({
        "ETF": etf,
        "é¡å‹": etf_type,
        "æœ€æ–°åƒ¹": round(df["Close"].iloc[-1], 2),
        "æœ€æ–°é…æ¯æ—¥": div_date,
        "æœ€è¿‘ä¸€æ¬¡é…æ¯": div_amt,
        "Sharpe": round(sharpe, 2),
        "Beta": round(beta, 2),
        "å¹´åŒ–å ±é…¬%": round(ann_ret, 2),
        "å¹´åŒ–æ³¢å‹•%": round(ann_vol, 2),
        "personal_score": round(personal_score, 3),
        "sharpe_fit": sharpe_fit,
        "return_fit": return_fit,
        "vol_fit": vol_fit,
        "beta_fit": beta_fit,
        "volume": vol_ma,
        "flow": flow,
        "volatility": volat
    })

df_all = pd.DataFrame(rows)

# HotIndex
for c in ["volume", "flow", "volatility"]:
    df_all[c + "_z"] = robust_z(df_all[c])

df_all["hot_index"] = (
    df_all["volume_z"]
    + df_all["flow_z"]
    - df_all["volatility_z"]
)

df_all["hot_index_norm"] = (
    df_all["hot_index"] - df_all["hot_index"].min()
) / (df_all["hot_index"].max() - df_all["hot_index"].min() + 1e-6)

df_all["final_score"] = (
    ALPHA_MODEL * df_all["hot_index_norm"]
    + (1 - ALPHA_MODEL) * df_all["personal_score"]
)

df_all = df_all.sort_values("final_score", ascending=False)

# ===============================
# UI
# ===============================
TOP_N = st.sidebar.slider("Top N ETF", 1, len(df_all), 5)

st.subheader("ğŸ¯ Top ETF æ’åºçµæœ")
st.dataframe(
    df_all.head(TOP_N)[[
        "ETF", "é¡å‹", "æœ€æ–°åƒ¹",
        "æœ€æ–°é…æ¯æ—¥", "æœ€è¿‘ä¸€æ¬¡é…æ¯",
        "final_score", "personal_score",
        "sharpe_fit", "return_fit",
        "vol_fit", "beta_fit"
    ]],
    use_container_width=True
)
