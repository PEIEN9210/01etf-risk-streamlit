# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y1jRJvzhlUjdd66vnUOBj57YzwXHYc1s
"""

# app.py
# -*- coding: utf-8 -*-

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import altair as alt

# ===============================
# Âü∫Êú¨Ë®≠ÂÆö
# ===============================
st.set_page_config(page_title="Âè∞ÁÅ£ ETF ÂÄã‰∫∫ÂåñÊé®Ëñ¶Á≥ªÁµ±", layout="wide")
st.title("üìä Âè∞ÁÅ£ ETF ÂÄã‰∫∫Âåñ + ÁÜ±ÈñÄ ETF Â§öÊ∫ñÂâáË≥áÁî¢ÊéíÂ∫èÊ°ÜÊû∂ÔºàÂÉÖ‰æõÁ†îÁ©∂ÂèÉËÄÉÔºâ")

TRADING_DAYS = 252
RISK_FREE_RATE = 0.01

# ===============================
# ETF Universe
# ===============================
ETF_LIST = {
    "0050.TW": "ËÇ°Á•®Âûã",
    "006208.TW": "ËÇ°Á•®Âûã",
    "00692.TW": "ËÇ°Á•®Âûã",
    "00757.TW": "ËÇ°Á•®Âûã",
    "0056.TW": "È´òËÇ°ÊÅØÂûã",
    "00878.TW": "È´òËÇ°ÊÅØÂûã",
    "00919.TW": "È´òËÇ°ÊÅØÂûã",
}
MARKET_BENCHMARK = "0050.TW"

# ===============================
# SidebarÔºöŒ∏ Ë®≠ÂÆö
# ===============================
st.sidebar.header("üë§ ÊäïË≥á‰∫∫È¢®Èö™Ë®≠ÂÆö")
age = st.sidebar.slider("Âπ¥ÈΩ°", 20, 80, 35)
horizon = st.sidebar.slider("ÊäïË≥áÂπ¥ÈôêÔºàÂπ¥Ôºâ", 1, 30, 10)
loss_tol = st.sidebar.slider("ÂèØÊé•ÂèóÊúÄÂ§ßÊêçÂ§± (%)", 0, 50, 20)
reaction = st.sidebar.radio("Â∏ÇÂ†¥‰∏ãË∑å 20% ÊôÇ", ["Ë≥£Âá∫", "ËßÄÊúõ", "Âä†Á¢º"])

theta = (
    (80 - age) / 60
    + horizon / 30
    + loss_tol / 50
    + {"Ë≥£Âá∫": 0, "ËßÄÊúõ": 0.5, "Âä†Á¢º": 1}[reaction]
) / 4
theta = np.clip(theta, 0, 1)
st.sidebar.metric("Œ∏ÔºàÈ¢®Èö™ÂÅèÂ•ΩÔºâ", round(theta, 2))

def alpha_from_theta(theta, a_min=0.1, a_max=0.7):
    return a_min + (a_max - a_min) * theta

ALPHA_MODEL = alpha_from_theta(theta)

# ===============================
# Data fetch
# ===============================
@st.cache_data(ttl=86400)
def fetch_all_price_data(etfs, benchmark, period="1y"):
    data = {}
    for code in set(list(etfs.keys()) + [benchmark]):
        df = yf.Ticker(code).history(period=period)
        if not df.empty and len(df) >= 50:
            data[code] = df
    return data

@st.cache_data(ttl=86400)
def fetch_dividend_info(code):
    try:
        t = yf.Ticker(code)
        div = t.dividends
        if div.empty:
            return {"ÊúÄÊñ∞ÈÖçÊÅØÊó•": None, "ÊúÄËøë‰∏ÄÊ¨°ÈÖçÊÅØ": 0, "TTMÈÖçÊÅØ": 0, "TTMÊÆñÂà©Áéá%": 0}
        one_year = pd.Timestamp.today() - pd.DateOffset(years=1)
        ttm = div[div.index >= one_year].sum()
        price = t.history(period="5d")["Close"].iloc[-1]
        return {
            "ÊúÄÊñ∞ÈÖçÊÅØÊó•": div.index[-1].date(),
            "ÊúÄËøë‰∏ÄÊ¨°ÈÖçÊÅØ": round(float(div.iloc[-1]), 3),
            "TTMÈÖçÊÅØ": round(float(ttm), 3),
            "TTMÊÆñÂà©Áéá%": round(float(ttm / price * 100), 2),
        }
    except Exception:
        return {"ÊúÄÊñ∞ÈÖçÊÅØÊó•": None, "ÊúÄËøë‰∏ÄÊ¨°ÈÖçÊÅØ": 0, "TTMÈÖçÊÅØ": 0, "TTMÊÆñÂà©Áéá%": 0}

# ===============================
# ÊåáÊ®ôË®àÁÆó
# ===============================
def calc_metrics(df, mkt):
    r = df["Close"].pct_change().dropna()
    mr = mkt["Close"].pct_change().dropna()
    idx = r.index.intersection(mr.index)
    r, mr = r.loc[idx], mr.loc[idx]
    ann_ret = r.mean() * TRADING_DAYS
    ann_vol = r.std() * np.sqrt(TRADING_DAYS)
    sharpe = (ann_ret - RISK_FREE_RATE) / ann_vol if ann_vol > 0 else 0
    beta = np.cov(r, mr)[0, 1] / np.var(mr)
    return ann_ret * 100, ann_vol * 100, sharpe, beta

def compute_hot_index(df, w=20):
    return {
        "volume_score": df["Volume"].rolling(w).mean().iloc[-1],
        "volatility": df["Close"].pct_change().rolling(w).std().iloc[-1],
        "flow_proxy": (df["Close"] * df["Volume"]).rolling(w).mean().iloc[-1],
    }

def robust_zscore(s):
    med = np.median(s)
    mad = np.median(np.abs(s - med))
    return (s - med) / mad if mad != 0 else 0

# ===============================
# ‰∏ªÊµÅÁ®ã
# ===============================
price_data = fetch_all_price_data(ETF_LIST, MARKET_BENCHMARK)
market_df = price_data[MARKET_BENCHMARK]

rows = []
for etf, etf_type in ETF_LIST.items():
    df = price_data.get(etf)
    if df is None:
        continue

    ann_ret, ann_vol, sharpe, beta = calc_metrics(df, market_df)
    hot = compute_hot_index(df)
    div = fetch_dividend_info(etf)

    rows.append({
        "ETF": etf,
        "È°ûÂûã": etf_type,
        "ÊúÄÊñ∞ÂÉπ": round(df["Close"].iloc[-1], 2),
        **div,
        "Sharpe": sharpe,
        "Beta": beta,
        "Âπ¥ÂåñÂ†±ÈÖ¨%": ann_ret,
        "Âπ¥ÂåñÊ≥¢Âãï%": ann_vol,
        **hot,
    })

df_all = pd.DataFrame(rows)
df_all["hot_index"] = df_all["volume_score"] + df_all["flow_proxy"] - df_all["volatility"]
df_all["hot_index_norm"] = robust_zscore(df_all["hot_index"])

# ===============================
# Œ∏-Ranking
# ===============================
THETA_LIST = [0, 0.25, 0.5, 0.75, 1.0]
theta_rankings = {}

for t in THETA_LIST:
    rws = []
    for _, r in df_all.iterrows():
        expected = 5 + t * 20
        acceptable = 10 + t * 25
        ideal_beta = 0.7 + t * 0.8

        sharpe_fit = min(r["Sharpe"] / 3, 1)
        return_fit = np.clip(1 - abs(r["Âπ¥ÂåñÂ†±ÈÖ¨%"] - expected) / expected, 0, 1)
        vol_fit = np.clip(1 - r["Âπ¥ÂåñÊ≥¢Âãï%"] / acceptable, 0, 1)
        beta_fit = np.clip(1 - abs(r["Beta"] - ideal_beta) / ideal_beta, 0, 1)

        personal = np.mean([sharpe_fit, return_fit, vol_fit, beta_fit])
        final = ALPHA_MODEL * r["hot_index_norm"] + (1 - ALPHA_MODEL) * personal

        rws.append({
            **r,
            "Œ∏": t,
            "personal_score": personal,
            "sharpe_fit": sharpe_fit,
            "return_fit": return_fit,
            "vol_fit": vol_fit,
            "beta_fit": beta_fit,
            "final_score": final,
        })

    theta_rankings[t] = pd.DataFrame(rws).sort_values("final_score", ascending=False)

theta_use = min(THETA_LIST, key=lambda x: abs(x - theta))
df_ui = theta_rankings[theta_use].head(5)

# ===============================
# UI
# ===============================
st.subheader("üéØ Top ETF")
st.dataframe(df_ui, use_container_width=True)

st.subheader("üí≠ Ê∞£Ê≥°Âúñ")
bubble = alt.Chart(df_ui).mark_circle(opacity=0.7).encode(
    x="sharpe_fit",
    y="personal_score",
    size="beta_fit",
    color="È°ûÂûã",
    tooltip=["ETF", "final_score"]
)
st.altair_chart(bubble, use_container_width=True)
