# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y1jRJvzhlUjdd66vnUOBj57YzwXHYc1s
"""

# app.py
# -*- coding: utf-8 -*-

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import altair as alt
from datetime import datetime, timedelta
from scipy.stats import spearmanr

# ===============================
# åŸºæœ¬è¨­å®š
# ===============================
st.set_page_config(page_title="å°ç£ ETF å€‹äººåŒ–æ¨è–¦ç³»çµ±", layout="wide")
st.title("ğŸ“Š å°ç£ ETF å€‹äººåŒ– + HotIndex ETF æ¨è–¦ç³»çµ±ï¼ˆåƒ…ä¾›åƒè€ƒï¼Œä¸æ§‹æˆæŠ•è³‡å»ºè­°ï¼‰")

TRADING_DAYS = 252
RISK_FREE_RATE = 0.01

# ===============================
# ETF Universe & å¸‚å ´åŸºæº–
# ===============================
ETF_LIST = {
    "0050.TW": "è‚¡ç¥¨å‹",
    "006208.TW": "è‚¡ç¥¨å‹",
    "00692.TW": "è‚¡ç¥¨å‹",
    "00757.TW": "è‚¡ç¥¨å‹",
    "0056.TW": "é«˜è‚¡æ¯å‹",
    "00878.TW": "é«˜è‚¡æ¯å‹",
    "00919.TW": "é«˜è‚¡æ¯å‹",
}

MARKET_BENCHMARK = "0050.TW"

# ===============================
# Sidebarï¼šä½¿ç”¨è€…è¨­å®š
# ===============================
st.sidebar.header("ğŸ‘¤ æŠ•è³‡äººé¢¨éšªè¨­å®š")

age = st.sidebar.slider("å¹´é½¡", 20, 80, 35)
horizon = st.sidebar.slider("æŠ•è³‡å¹´é™ï¼ˆå¹´ï¼‰", 1, 30, 10)
loss_tol = st.sidebar.slider("å¯æ¥å—æœ€å¤§æå¤± (%)", 0, 50, 20)
reaction = st.sidebar.radio("å¸‚å ´ä¸‹è·Œ 20% æ™‚çš„åæ‡‰", ["è³£å‡º", "è§€æœ›", "åŠ ç¢¼"])

theta = (
    (80 - age) / 60
    + horizon / 30
    + loss_tol / 50
    + {"è³£å‡º": 0, "è§€æœ›": 0.5, "åŠ ç¢¼": 1}[reaction]
) / 4

theta = np.clip(theta, 0, 1)
st.sidebar.metric("Î¸ï¼ˆé¢¨éšªåå¥½æŒ‡æ•¸ï¼‰", round(theta, 2))

# ===============================
# HotIndex vs å€‹äººåŒ–åˆ†æ•¸æ¬Šé‡
# ===============================
st.sidebar.header("âš–ï¸ ç¶œåˆåˆ†æ•¸æ¬Šé‡")

ALPHA = st.sidebar.slider(
    "HotIndex æ¬Šé‡ï¼ˆå€‹äººåŒ–åˆ†æ•¸ = 1 - HotIndexï¼‰",
    0.0,
    1.0,
    0.5,
    step=0.05,
)

# ===============================
# æ’åºèˆ‡é¡¯ç¤ºè¨­å®š
# ===============================
TOP_N = st.sidebar.slider("Top N ETF", 1, len(ETF_LIST), 5)

# ===============================
# æŠ“å–åƒ¹æ ¼è³‡æ–™ï¼ˆæ¯æ—¥å¿«å–ï¼‰
# ===============================
@st.cache_data(ttl=86400)
def fetch_price_data(code, period="1y"):
    df = yf.Ticker(code).history(period=period)
    if df.empty or len(df) < 50:
        return None
    return df

# ===============================
# æŒ‡æ¨™è¨ˆç®—
# ===============================
def calc_metrics(df, market_df):
    r = df["Close"].pct_change().dropna()
    mr = market_df["Close"].pct_change().dropna()

    idx = r.index.intersection(mr.index)
    r, mr = r.loc[idx], mr.loc[idx]

    ann_ret = r.mean() * TRADING_DAYS
    ann_vol = r.std() * np.sqrt(TRADING_DAYS)
    sharpe = (ann_ret - RISK_FREE_RATE) / ann_vol if ann_vol > 0 else 0
    beta = np.cov(r, mr)[0, 1] / np.var(mr)

    return ann_ret * 100, ann_vol * 100, sharpe, beta


def compute_hot_index(df, window=20):
    volume_ma = df["Volume"].rolling(window).mean().iloc[-1]
    returns = df["Close"].pct_change()
    volatility = returns.rolling(window).std().iloc[-1]
    flow_proxy = (df["Close"] * df["Volume"]).rolling(window).mean().iloc[-1]
    return volume_ma + flow_proxy - volatility


# ===============================
# å€‹äººåŒ–åˆ†æ•¸ï¼ˆÎ¸ é©…å‹•ï¼‰
# ===============================
def compute_personalized_score(ann_ret, ann_vol, sharpe, beta, theta):
    expected_return = 5 + theta * 20
    acceptable_vol = 10 + theta * 25
    ideal_beta = 0.7 + theta * 0.8

    sharpe_fit = min(sharpe / 3, 1)
    return_fit = np.clip(1 - abs(ann_ret - expected_return) / expected_return, 0, 1)
    vol_fit = np.clip(1 - ann_vol / acceptable_vol, 0, 1)
    beta_fit = np.clip(1 - abs(beta - ideal_beta) / ideal_beta, 0, 1)

    personal_score = np.mean([return_fit, vol_fit, beta_fit])

    return {
        "personal_score": personal_score,
        "sharpe_fit": sharpe_fit,
        "return_fit": return_fit,
        "vol_fit": vol_fit,
        "beta_fit": beta_fit,
    }


def compute_final_score(hot_index, personal_score):
    return ALPHA * hot_index + (1 - ALPHA) * personal_score


# ===============================
# ä¸»æµç¨‹ï¼ˆä¸€æ¬¡æŠ“è³‡æ–™ï¼‰
# ===============================
market_df = fetch_price_data(MARKET_BENCHMARK)
price_cache = {etf: fetch_price_data(etf) for etf in ETF_LIST}

# ===============================
# Î¸ Robustness æ’åº
# ===============================
THETA_LIST = [0.0, 0.25, 0.5, 0.75, 1.0]
theta_rankings = {}

for t in THETA_LIST:
    rows = []
    for etf, etf_type in ETF_LIST.items():
        df = price_cache.get(etf)
        if df is None or market_df is None:
            continue

        ann_ret, ann_vol, sharpe, beta = calc_metrics(df, market_df)
        comp = compute_personalized_score(ann_ret, ann_vol, sharpe, beta, t)
        hot_index = compute_hot_index(df)
        final_score = compute_final_score(hot_index, comp["personal_score"])

        rows.append(
            {
                "ETF": etf,
                "é¡å‹": etf_type,
                "Î¸": t,
                "final_score": final_score,
                "hot_index": hot_index,
                **comp,
            }
        )

    df_theta = pd.DataFrame(rows).sort_values("final_score", ascending=False)
    theta_rankings[t] = df_theta.reset_index(drop=True)

# ===============================
# UIï¼šé¡¯ç¤ºæœ€è¿‘é„° Î¸
# ===============================
theta_display = min(THETA_LIST, key=lambda x: abs(x - theta))
df_ui = theta_rankings[theta_display].head(TOP_N)

st.subheader(f"ğŸ¯ Top {TOP_N} ETFï¼ˆÎ¸ â‰ˆ {round(theta,2)}ï¼‰")
st.dataframe(df_ui, use_container_width=True)

# ===============================
# Ranking Robustnessï¼ˆSpearmanï¼‰
# ===============================
base = theta_rankings[0.5]["ETF"]

rank_corr = {}
for t, df_t in theta_rankings.items():
    aligned = df_t.set_index("ETF").loc[base].reset_index()
    corr, _ = spearmanr(range(len(aligned)), aligned.index)
    rank_corr[t] = round(corr, 3)

st.caption(f"ğŸ“ æ’åºç©©å®šæ€§ï¼ˆSpearman vs Î¸=0.5ï¼‰ï¼š{rank_corr}")

# ===============================
# é›·é”åœ–
# ===============================
metrics = ["return_fit", "vol_fit", "beta_fit"]
radar = df_ui.melt(id_vars="ETF", value_vars=metrics, var_name="æŒ‡æ¨™", value_name="å€¼")
radar["order"] = radar["æŒ‡æ¨™"].map({m: i for i, m in enumerate(metrics)})
radar["angle"] = radar["order"] * 2 * np.pi / len(metrics)
radar["x"] = radar["å€¼"] * np.cos(radar["angle"])
radar["y"] = radar["å€¼"] * np.sin(radar["angle"])

chart = (
    alt.Chart(radar)
    .mark_line(point=True)
    .encode(x="x:Q", y="y:Q", color="ETF:N", detail="ETF:N")
)

st.subheader("ğŸ“¡ ETF é¢¨éšªé©é…é›·é”åœ–")
st.altair_chart(chart, use_container_width=True)
